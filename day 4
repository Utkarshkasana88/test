xfrom datetime import datetime

def ms_to_dt(ms):
    return datetime.fromtimestamp(ms / 1000)

def overlapping_seconds(start1, end1, start2, end2):
    """Returns the number of seconds of overlap between two intervals"""
    latest_start = max(start1, start2)
    earliest_end = min(end1, end2)
    delta = (earliest_end - latest_start).total_seconds()
    return max(0, delta)

def calculate_fair_run_cost(run_start_ms, run_end_ms, cluster_cost, all_other_runs):
    """
    Params:
    - run_start_ms, run_end_ms: Your job run's start and end (ms)
    - cluster_cost: Total cluster cost for that time window (float)
    - all_other_runs: List of dicts with 'run_id', 'start_time_ms', 'end_time_ms'

    Returns:
    - Dict with your run cost breakdown
    """
    run_start = ms_to_dt(run_start_ms)
    run_end = ms_to_dt(run_end_ms)
    
    your_duration = (run_end - run_start).total_seconds()
    if your_duration <= 0:
        raise ValueError("Invalid run duration")

    total_shared_duration = 0
    run_overlaps = []

    for r in all_other_runs:
        other_start = ms_to_dt(r['start_time_ms'])
        other_end = ms_to_dt(r['end_time_ms'])
        overlap = overlapping_seconds(run_start, run_end, other_start, other_end)
        if overlap > 0:
            run_overlaps.append({
                "run_id": r['run_id'],
                "overlap_seconds": overlap
            })
            total_shared_duration += overlap

    your_share = your_duration / total_shared_duration if total_shared_duration > 0 else 1.0
    run_cost = your_share * cluster_cost

    return {
        "your_run_duration_minutes": round(your_duration / 60, 2),
        "total_shared_duration_minutes": round(total_shared_duration / 60, 2),
        "your_usage_share": round(your_share, 4),
        "your_estimated_run_cost": round(run_cost, 4),
        "run_overlaps": run_overlaps
    }
